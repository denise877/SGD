# -*- coding: utf-8 -*-
"""Project2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qp84GKFoMsTR97nCTdBqiEVP6Ksn0f50

Task1
"""

# generate a vector of random numbers which obeys the given distribution.
#
# n: length of the vector
# mu: mean value
# sigma: standard deviation.
# dist: choices for the distribution, you need to implement at least normal 
#       distribution and uniform distribution.
#
# For normal distribution, you can use ``numpy.random.normal`` to generate.
# For uniform distribution, the interval to sample will be [mu - sigma/sqrt(3), mu + sigma/sqrt(3)].
import matplotlib.pyplot as plt
import numpy as np
import math

def generate_random_numbers(n, mu, sigma, dist="normal"):
    # write your code here.
    if dist == "normal":
        return np.random.normal(mu, sigma, n)
    elif dist == "uniform":
        # write your code here.
        return np.random.uniform(mu - sigma/math.sqrt(3), mu + sigma/math.sqrt(3), n)
    else:
        raise Exception("The distribution {unknown_dist} is not implemented".format(unknown_dist=dist))
        
        
# test your code:
y_test = generate_random_numbers(5, 0, 0.1, "normal")

y1 = generate_random_numbers(105, 0.5, 1.0, "normal")
y2 = generate_random_numbers(105, 0.5, 1.0, "uniform")

# IGD, the ordering is permitted to have replacement. 
#
#

a = np.linspace(0, 105, 106)

def IGD_wr_task1(y):
    n = len(y)
    ordering = np.random.choice(n, n, replace=True)
    x0=0
    xn=x0
    seq=[]
    k=0
    s=0
    for i in range(n):
        s+=(xn-y[i])**2
    seq.append((1/2)*s)
    while k <= n-1:
      gamma=1/(k+1)
      ik=ordering[k]
      yik=y[ik]
      xn=xn-gamma*(xn-yik)
      s=0
      for i in range(n):
        s+=(xn-y[i])**2
      seq.append((1/2)*s)
      k+=1
  
      
    return xn,seq 
    # implement the algorithm's iteration of IGD. Your result should return the the final xk
    # at the last iteration and also the history of objective function at each xk.
    
      


# IGD, the ordering is not permitted to have replacement.
#
#
def IGD_wo_task1(y):
    n = len(y)
    ordering = np.random.choice(n, n, replace=False)
    x0=0
    xn=x0
    seq=[]
    k=0
    s=0
    for i in range(n):
        s+=(xn-y[i])**2
    seq.append((1/2)*s)
    while k <= n-1:
      gamma=1/(1+k)
      ik=ordering[k]
      yik=y[ik]
      xn=xn-gamma*(xn-yik)
      s=0
      for i in range(n):
        s+=(xn-y[i])**2
      seq.append((1/2)*s)
      k+=1
    obj2=[]
    
    
    
    return xn,seq
    # implement the algorithm's iteration of IGD. Your result should return the the final xk
    # at the last iteration and also the history of objective function at each xk.

r1=np.mean([IGD_wo_task1(y1)[1] for i in range(100)],axis=0)
r2=np.mean([IGD_wr_task1(y1)[1] for i in range(100)],axis=0)
plt.semilogy(a, r1, label='wo')
plt.semilogy(a, r2, label='wr')
plt.legend()
plt.show()
    
r1=np.mean([IGD_wo_task1(y1)[1] for i in range(100)],axis=0)
r2=np.mean([IGD_wr_task1(y1)[1] for i in range(100)],axis=0)
plt.semilogy(a[50:], r1[50:], label='wo')
plt.semilogy(a[50:], r2[50:], label='wr')
plt.legend()
plt.show()

r1=np.mean([IGD_wo_task1(y2)[1] for i in range(100)],axis=0)
r2=np.mean([IGD_wr_task1(y2)[1] for i in range(100)],axis=0)
plt.semilogy(a, r1, label='wo')
plt.semilogy(a, r2, label='wr')
plt.legend()
plt.show()
    
r1=np.mean([IGD_wo_task1(y2)[1] for i in range(100)],axis=0)
r2=np.mean([IGD_wr_task1(y2)[1] for i in range(100)],axis=0)
plt.semilogy(a[50:], r1[50:], label='wo')
plt.semilogy(a[50:], r2[50:], label='wr')
plt.legend()
plt.show()

"""Task2"""

# IGD, the ordering is permitted to have replacement. 
#
#
beta=np.random.uniform(0.5, 1.0, 20)
beta_inv = np.reciprocal(beta)
a = np.linspace(0, 20, 21)


def IGD_wr_task2(beta):
    n = len(beta)
    ordering = np.random.choice(n, n, replace=True)
    k=0
    x0=0
    ys=10
    xn=x0
    seq=[]
    s=0
    for i in range(len(beta)):
      s+=beta[i]*(xn-ys)**2
    seq.append((1/2)*s)
    while k <= n-1:
      gamma=0.5*(min(beta_inv))
      ik=ordering[k]
      xn=xn-gamma*(xn-ys)*beta[ik]
      s=0
      for i in range(len(beta)):
        s+=beta[i]*(xn-ys)**2
      seq.append((1/2)*s)
      k+=1

    
    return xn,seq
      
    # implement the algorithm's iteration of IGD. Your result should return the the final xk
    # at the last iteration and also the history of objective function at each xk.
    


# IGD, the ordering is not permitted to have replacement.
#
#

def IGD_wo_task2(beta):
    n = len(beta)
    ordering = np.random.choice(n, n, replace=False)
    # implement the algorithm's iteration of IGD. Your result should return the the final xk
    # at the last iteration and also the history of objective function at each xk.
    k=0
    x0=0
    ys=10
    xn=x0
    seq=[]
    s=0
    for i in range(len(beta)):
      s+=beta[i]*(xn-ys)**2
    seq.append((1/2)*s)
    while k <= n-1:
      gamma=0.5*(min(beta_inv))
      ik=ordering[k]
      xn=xn-gamma*(xn-ys)*beta[ik]
      s=0
      for i in range(len(beta)):
        s+=beta[i]*(xn-ys)**2
      seq.append((1/2)*s)
      k+=1

  
    return xn,seq

r1=np.mean([IGD_wo_task2(beta)[1] for i in range(100)],axis=0)
r2=np.mean([IGD_wr_task2(beta)[1] for i in range(100)],axis=0)
plt.semilogy(a, r1, label='wo')
plt.semilogy(a, r2, label='wr')
plt.legend()
plt.show()

"""Task3"""

# generation of exact solution and data y and matrix A.

def generate_problem_task3(m, n, rho):
    A = np.random.normal(0., 1.0, (m, n))
    x = np.random.random(n) # uniform in (0,1)
    w = np.random.normal(0., rho, m)
    y = A@x + w
    return A, x, y

# We generate the problem with 200x100 matrix. rho as 0.01.
#
A, xstar, y = generate_problem_task3(200, 100, 0.01)

# In these two functions, we could only focus on the first n steps and try to make comparisons on these data only.
# In practice, it requires more iterations to converge, due to the matrix might not be easy to deal with.
# You can put the ordering loop into a naive loop: namely, we simply perform the IGD code several rounds.
#
#
#
# IGD, the ordering is permitted to have replacement. 
#
#
wi = np.random.normal(0, 10**(-4), 100)
a = np.linspace(0, 100, 101)


def IGD_wr_task3(y, A):
    n = len(A[0])
    ordering = np.random.choice(n, n, replace=True)
    k=0
    x0 = np.zeros(n)
    seq = []
    conv = []
    xn=x0
    obj1=[]
    s=0
    for i in range(len(y)):
         s+=(np.dot(A[i].T,xn)-y[i])**2
    obj1.append((1/2)*s)
    conv.append((np.linalg.norm(xn - xstar))**2)
    while k <= n-1:
      conv.append((np.linalg.norm(xn - xstar))**2)
      ik=ordering[k]
      yik=y[ik]
      xn=xn-(0.001*(A[ik])*(np.dot((A[ik].T),xn)-yik))
      s=0
      for i in range(len(y)):
         s+=(np.dot(A[i].T,xn)-y[i])**2
      obj1.append((1/2)*s)
      k+=1
    return xn,obj1, conv
      
    
    # implement the algorithm's iteration of IGD. Your result should return the the final xk
    # at the last iteration and also the history of objective function at each xk.



# IGD, the ordering is not permitted to have replacement.
#
#
def IGD_wo_task3(y, A):
    # implement the algorithm's iteration of IGD. Your result should return the the final xk
    # at the last iteration and also the history of objective function at each xk.
    n = len(A[0])
    ordering = np.random.choice(n, n, replace=False)
    k=0
    x0 = np.zeros(n)
    seq = []
    conv = []
    xn=x0
    obj1=[]
    s=0
    for i in range(len(y)):
         s+=(np.dot(A[i].T,xn)-y[i])**2
    obj1.append((1/2)*s)
    conv.append((np.linalg.norm(xn - xstar))**2)
    while k <= n-1:
      conv.append((np.linalg.norm(xn - xstar))**2)
      ik=ordering[k]
      yik=y[ik]
      xn=xn-(0.001*(A[ik])*(np.dot((A[ik].T),xn)-yik))
      s=0
      for i in range(len(y)):
         s+=(np.dot(A[i].T,xn)-y[i])**2
      obj1.append((1/2)*s)
      k+=1
    return xn,obj1, conv
  




r1=np.mean([IGD_wo_task3(y,A)[1] for i in range(100)],axis=0)
r2=np.mean([IGD_wr_task3(y,A)[1] for i in range(100)],axis=0)
plt.semilogy(a, r1, label='wo')
plt.semilogy(a, r2, label='wr')
plt.legend()
plt.show()

r1=np.mean([IGD_wo_task3(y,A)[2] for i in range(100)],axis=0)
r2=np.mean([IGD_wr_task3(y,A)[2] for i in range(100)],axis=0)
plt.semilogy(a, r1, label='wo')
plt.semilogy(a, r2, label='wr')
plt.legend()
plt.show()